///////////////////////////////////////////////////////////////////////////////
// Module1.h
#pragma once

#include "Untitled1Interfaces.h"
#include "AdsR0.h"
#include "Motor.h"
#include "UserInterface.h"


// parameter ids for TwinCAT module Module1 with disabled code generation
// could be moved to Untitled1Services.h
const PTCID PID_Module1AdsPort        = 0x00000002;

class CModule1 
	: public ITComObject
	, public ITcADI
	, public ITcWatchSource
///<AutoGeneratedContent id="InheritanceList">
	, public ITcCyclic
///</AutoGeneratedContent>
	, public CAdsR0FifoPort
{
public:
	DECLARE_IUNKNOWN()
DECLARE_IPERSIST(CID_Untitled1CModule1)
DECLARE_ITCOMOBJECT_LOCKOP()
DECLARE_ITCADI()
DECLARE_ITCWATCHSOURCE()
DECLARE_OBJPARAWATCH_MAP()
DECLARE_OBJDATAAREA_MAP()



CModule1();
virtual	~CModule1();


///<AutoGeneratedContent id="InterfaceMembers">
	// ITcCyclic
virtual HRESULT TCOMAPI CycleUpdate(ITcTask* ipTask, ITcUnknown* ipCaller, ULONG_PTR context);

///</AutoGeneratedContent>

	// CAds
virtual	void	AdsReadWriteInd
(
	AmsAddr& rAddr,
	ULONG invokeId,
	ULONG indexGroup,
	ULONG indexOffset,
	ULONG cbReadLength,
	ULONG cbWriteLength,
	PVOID pData
);

virtual void AdsReadCon
(
	AmsAddr& rAddr,
	ULONG invokeId,
	ULONG result,
	ULONG cbLength,
	PVOID pData
);

protected:
	DECLARE_ITCOMOBJECT_SETSTATE();

	HRESULT AddModuleToCaller();
	VOID RemoveModuleFromCaller();
	void Init(); // need to removed..

	// Tracing
	CTcTrace m_Trace;

	///<AutoGeneratedContent id="Members">
	TcTraceLevel m_TraceLevelMax;
	WORD m_DefaultAdsPort;
	WORD m_ContextAdsPort;
	ULONG m_Counter;
	SHORT m_move;
	LONG m_target;
	Module1Inputs m_Inputs;
	Module1Outputs m_Outputs;
	Module1DataArea3 m_DataArea3;

	ITcCyclicCallerInfoPtr m_spCyclicCaller;

	///</AutoGeneratedContent>

	void SubmitAdsReadReq();
	enum
	{
		invokeIdReadByOidAndPid = 1
	};
	ULONG  m_ReadByOidAndPid;


	unsigned long command_;
	unsigned long status_;
	unsigned long error_;
	std::vector<Motor> motors; // motors(10) ?? static ??
	static constexpr INT timeout_cnt =1000;

private:
	static constexpr USHORT switch_on_disabled = 0x0040;
	static constexpr USHORT ready_to_switch_on = 0x0021;
	static constexpr USHORT switch_on          = 0x0023;
	static constexpr USHORT operation_enabled  = 0x0027;
	static constexpr USHORT fault              = 0x0008;
	static constexpr USHORT quick_stop_active  = 0x0007;
	static constexpr USHORT target_reached     = 0x0400;
	


	


	void servo_off()
	{	
		for (auto motor = motors.begin(); motor != motors.end(); motor++) {
			/* transition 7, 9, 10, 12 */
			m_Outputs.control_word = command::disable_voltage;
			
			if ((m_Inputs.status_word & fault) == fault) {
				/* transition 15 */
				m_Outputs.control_word = command::disable_voltage;
				m_DataArea3.state = state::recovery;
			}
		}
		for (auto motor = motors.begin(); motor != motors.end(); motor++) {
			if ((m_Inputs.status_word & switch_on_disabled) != switch_on_disabled) {
				return;
			}
		}
		m_DataArea3.state = state::standby; 
		
	};
	void servo_on()
	{
		static INT cnt = 0;
		if (cnt++ > timeout_cnt) {
			m_DataArea3.state = state::error;
			cnt = 0;
			return;
		}

		for (auto motor = motors.begin(); motor != motors.end(); motor++) {
			
			if ((m_Inputs.status_word & fault) == fault) {
				m_Outputs.control_word = command::disable_voltage;
				m_DataArea3.state = state::recovery;
			}
			else if ((m_Inputs.status_word & switch_on_disabled) == switch_on_disabled) {
				m_Outputs.control_word = command::shutdown;
			}
			else if ((m_Inputs.status_word & operation_enabled) == operation_enabled) {
				m_Outputs.control_word = command::switch_on_and_enable_oepration;
			}
			else if ((m_Inputs.status_word & switch_on) == switch_on) {
				m_Outputs.control_word = command::enable_operation;
			}
			else if ((m_Inputs.status_word & ready_to_switch_on) == ready_to_switch_on) {
				m_Outputs.control_word = command::switch_on;
			}
			else {
				/* do nothing */
			}
			
		}


		for (auto motor = motors.begin(); motor != motors.end(); motor++) {
			if ((m_Inputs.status_word & operation_enabled) != operation_enabled) {
				return;
			}
		}

		m_DataArea3.state = state::set_position; 
		cnt = 0;
	};


	void set_position() 
	{
		for (auto motor = motors.begin(); motor != motors.end(); motor++) {
			m_Outputs.target = m_DataArea3.target_position;
		}

		for (auto motor = motors.begin(); motor != motors.end(); motor++) {
			if ((m_Inputs.status_word & target_reached) != target_reached) {
				return;
			}
			motor->UpdateCurrentPosition(m_DataArea3.target_position);
		}

		m_DataArea3.state = state::standby; // servo off ? 
	};


	void fault_recovery() {
		for (auto motor = motors.begin(); motor != motors.end(); motor++) {
			//transition 15
			m_Outputs.control_word = command::fault_reset;
		}

		for (auto motor = motors.begin(); motor != motors.end(); motor++) {
			if ((m_Inputs.status_word & switch_on_disabled) != switch_on_disabled) {
				m_Outputs.control_word = command::disable_voltage;
				return;
			}
		}
		m_DataArea3.state = state::standby;
	};

};



